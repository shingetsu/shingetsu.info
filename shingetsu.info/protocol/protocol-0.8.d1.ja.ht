>>>define TITLE         新月プロトコル 0.8 ドラフト#1
>>>define DESCRIPTION   IPv6アドレス
>>>define BASE          protocol-0.8.d1
>>>define SECTION       プロトコル
>>>include "head.ja.h"

<p class="date">2025-02-11</p>

<h2>はじめに</h2>
<p>新月は複数のノードが協調して動作しており、
そこには何らかのプロトコルが存在すると考えられる。
これを第1次のプロトコルと呼ぶ。
この文書は第1次のプロトコルを明文化して再定義することを試みるものであるが、
残念ながら未だ完全なものではない。</p>

<p>この文書で定義する新月プトロコルのバージョンは0.8である。
プロトコルは次の4つの層から成る。</p>

<ol>
  <li><a href="#communication">通信層</a></li>
  <li><a href="#intermediate">中間層</a></li>
  <li><a href="#application">アプリケーション層</a></li>
  <li><a href="#group">アプリケーショングループ</a></li>
</ol>

<h2 id="communication">通信層</h2>
<h3>新月ネットワークの構成</h3>
<p>新月のネットワークはノード間の接続によって構成される。
各々のノードはネットワーク上で一意な名前を持つ。
この一意な名前をノード名という。
ネットワーク上の各々のノードは、
他のノードと通信を行うために他のノード名を保持する。
あるノードがネットワークの維持のために保持している
他のノード名のことを隣接ノードと呼ぶ。
隣接ノード同士は互いに相手のノード名を保持していることが望ましいが、
保証される必要はない。</p>

<p>ノード間の通信はHTTP/1.0またはHTTP/1.1の仕様に従って行う。
ノード間のリクエスト・レスポンスのメッセージは
GETメソッドの規約に従わなければならない。</p>

<p>ノードのレスポンスは便宜的に
文字エンコーディングがUTF-8であるプレインテキストとみなす。
厳密にはレスポンスは構造化されており、
各部分について文字エンコーディングが定義されている。</p>

<p>新月のノード間の通信コマンドは最終的にURLとして構築される。
他のノードに送信するコマンドはURL の仕様に従わなければならない。</p>

<h3>ノード</h3>
<p>新月プロトコルを実装しているプログラム・コンピュータの1単位をノードという。
新月ネットワークに接続するノードは
新月プロトコルを満たすよう正確に実装しなければならない。
プログラムの新月プロトコルの実装にあたっては、
HTTP、URL の仕様も満たさなければならない。</p>

<p>ノードはネットワーク上で一意の名前を持つ。これをノード名といった。
ノード名の形式は次のように定義する:</p>

<pre>ホスト名:ポート番号/パス名</pre>

<p>ここでホスト名はDNS名またはIPv4のIPアドレスまたは角括弧([])で囲まれたIPv6のIPアドレスとする。
ポート番号は10進表現の整数である。</p>

<p>新月プロトコルは、ノード名の構成要素であるポート番号を指定しない。
各々のノードはノード名に使用するポート番号を自由に設定することができる。
ノード名に使用するポート番号が1024未満の場合は、
ウェルノウンポート番号に従うべきである。</p>

<h3>メッセージ</h3>
<p>ノード間でリクエスト・レスポンス時に交換する情報をメッセージという。
メッセージの内容は多岐にわたる。
例えば、/ping コマンドに対するレスポンスである
通信相手のノードのIP アドレスがある。
/getコマンドで交換するファイルもある。</p>

<p>通信相手ノードにリクエストメッセージを送信し、
レスポンスメッセージを受信するノードは、
圧縮されていない通常のメッセージに加えて、
gzip 形式で圧縮しているメッセージも解釈できることが望ましい。
ただし、gzip 形式で圧縮したメッセージをノードに送信する場合、
通信相手ノードはリクエストのメッセージヘッダを解析し、
ノードがgzip形式で圧縮されたメッセージを解釈できるかどうか
判断しなければならない。
もし、判断後ノードがgzip形式で圧縮されたメッセージが解釈可能であれば、
gzip形式で圧縮したメッセージを送信する。
圧縮されているメッセージを解釈できるノードは、
できるだけ通信相手ノードにそれが可能な旨を通知すべきである。
メッセージの圧縮を行うことにより、メッセージを圧縮することができ、
圧縮通信の利点を享受できる。</p>

<h3>時刻</h3>
<p>新月プロトコルで用いる基点時刻は
「1970年1月1日午前0時(グリニッジ標準時)」である。
ある時刻は基点時刻を基準として表される整数値の秒で表す。</p>

<h3>ノード間のプロトコルコマンド</h3>
<p>ノード間の通信はプロトコルコマンドを送信することによって行う。
プロトコルコマンドはノード名から生成したURLのパス部の末尾に付加する。
プロトコルコマンドを付加したURLの例を示す:</p>

<pre>http://example.com:8000/server.cgi/ping</pre>

<p>次に、ノード間で通信を確立するためのプロトコルコマンドと、
それを受けたノードの振舞いを示す。
\nは改行コード(0x0a)を表わす。</p>

<dl>
  <dt>/ping</dt>
  <dd>ノードは「PONG\n相手ノードのIPアドレス」を返す。</dd>

  <dt>/node</dt>
  <dd>ノードはノード自身が接続しているノードを1つ選択し、
      そのノード名を返す。</dd>

  <dt>/join/ノード名</dt>
  <dd>相手を隣接ノードに加えるかどうかを判断し、
      加えるのであれば「WELCOME」または「WELCOME\n別のノードのノード名」
      を返す。
      判断には相手ノードが指定するノード名が有効であることを
      /pingによって確かめること、
      相手ノードのノード名のDNS名部分が、
      接続しようとしている相手ノード自身を示しているかどうかの検査
      などが考えられるが、ここでは定義しない。
      相手ノードのノード名のホスト名は省略することができる。
      ノード名のパスは/を+ に置き換えたものとする。
      相手ノードにはノード保持リストに加えてもらい、
      レスポンスで指定したノードに接続することを期待する。</dd>

  <dt>/bye/ノード名</dt>
  <dd>隣接ノードリストから相手ノードを削除し、「BYEBYE」を返す。
      判断には相手ノードのノード名のDNS名部分が、
      接続しようとしている相手ノード自身を示しているかどうかの検査
      などが考えられるが、ここでは定義しない。</dd>

  <dt>/have/ファイル名</dt>
  <dd>ファイル名のファイルを持っていれば「YES」、
      そうでなければ「NO」を返す。</dd>

  <dt>/get/ファイル名/時刻引数</dt>
  <dd>ファイル名で指定したファイルの、時刻引数を満たすレコードを返す。
      時刻引数は次のうちどれかひとつである:
      <ul>
        <li>「時刻」指定した時刻のレコード</li>
        <li>「-時刻」指定した時刻以前のレコードすべて</li>
        <li>「時刻-」指定した時刻以降のレコードすべて</li>
        <li>「時刻-時刻」指定した時刻の間のレコードすべて</li>
        <li>「時刻/識別子」指定した時刻と識別子のレコード</li>
      </ul></dd>

  <dt>/head/ファイル名/時刻引数</dt>
  <dd>/get と同様のレスポンスである。
      ただし、各レコードの時刻と識別子のみを返す。</dd>

  <dt>/update/ファイル名/時刻/識別子/ノード名</dt>
  <dd>ノードにファイルが更新されたことを知らせる。
      もしすでにファイルの更新に関する処理をしているのなら何もしない。
      自分の持っているファイルならば、それを更新したのち、
      ノード名を自ノードのノード名に書き換えて接続しているノードにも通知する。
      そうでなければそのまま、
      送信されてきたプロトコルコマンドを接続しているノードに転送する。
      ノード名のパスは/を+に置き換えたものとする。
      /joinと同様にホスト名を省略できる。</dd>

  <dt>/recent/時刻引数</dt>
  <dd>時刻引数で指定した範囲の/update命令のあったレコード名を
      擬似的なファイルとして返す。
      時刻引数は次のうちどれかひとつである:
      <ul>
        <li>「時刻」指定した時刻のレコード</li>
        <li>「-時刻」指定した時刻以前のレコードすべて</li>
        <li>「時刻-」指定した時刻以降のレコードすべて</li>
        <li>「時刻-時刻」指定した時刻の間のレコードすべて</li>
      </ul>
      レスポンスは次のようになる。
      <pre>タイムスタンプ&lt;&gt;識別子&lt;&gt;ファイル名</pre>
      各行にはタグと呼ばれる文字列を加えることができ、
      その場合の書式は次のようになる。
      <pre>タイムスタンプ&lt;&gt;識別子&lt;&gt;ファイル名&lt;&gt;tag:タグ群</pre>
      タグ群とはタグをスペースで区切ったものである。
      タグにはスペース, &lt;, &gt;, &amp; を使うことができない。</dd>

   <dt>/</dt>
   <dd>ノード固有のメッセージを表示する。
   通信には使わないので、何を出力してもよい。</dd>
</dl>

<h3>ファイルの伝播</h3>
<p>ノードは、ファイルの内容に変更が生じたときに、
変更された事実を/updateコマンドを使用して他のノードへ通知することができる。
ファイルの変更があったことを通知するかどうかの判断の処理は、
実装によって異なる。</p>

<h3>ファイル</h3>
<p>1つの掲示板を構成する、0個以上のレコードの集合をファイルと呼ぶ。
それらのレコードを\nで接続した書式を持つ。
ファイルは無限の長さを持っており、
実際には1つのファイルの全体を目にすることはできない。
ノードが扱うのは常にファイルの一部である。</p>

<h3>レコード</h3>
<p>レコードとはファイルを構成する要素のことである。
レコードの形式は、次のように定義する:</p>

<pre>タイムスタンプ&lt;&gt;識別子&lt;&gt;本文</pre>

<p>識別子は本文のMD5値である。
レコードの要素は&lt;&gt;で区切る。
タイムスタンプは基準時刻から経過した整数値の秒数を表す。</p>

<h2 id="intermediate">中間層</h2>
<h3>ファイル名</h3>
<p>ファイル名は prefix_basename という形式である。
prefixに使える文字は半角英数字、
basenameに使える文字は半角英数字とアンダースコア(_)である。</p>

<p>prefixはファイルの種類を表す。
basenameはファイルの「名前」などを表わすことになるだろう。
ファイル名を定義するのはアプリケーションである。</p>

<h3>本文の書式</h3>
<p>本文を構成する要素は「&lt;&gt;」で区切る。
本文は複数の名前付きフィールドで構成される。
名前付きフィールドの形式は「名前:値」である。
名前付きフィールドの名前に使える文字は半角英数字とアンダースコア(_)である。
名前付きフィールドの名前は重複してはならない。
重複した場合の例外処理は実装依存である。
名前付きフィールドのstamp, id は予約されており、
それぞれタイムスタンプ、識別子を表わす。
本文での名前付きフィールドの出現順番は問わない。
名前付きフィールドのフィールド値には「&lt;」「&gt;」が含まれてはならない。
例外として「&lt;文字列&gt;」(タグと呼ぶ)を含むことができる
(文字列は長さが1 文字以上であって、「&lt;」「&gt;」が含まれてはならない)。
どのようなタグが使えるのかはアプリケーションが定める。</p>

<h3>署名</h3>
<p>署名の定義は<a href="http://shingetsu.info/protocol/protocol-0.5-2.pdf">新月プロトコル0.5 ドラフト#2 PDF</a>を参照せよ。</p>

<h3>署名に関連する名前付きフィールド</h3>
<dl>
  <dt>pubkey</dt>
  <dd>署名の公開鍵を記す。</dd>
  <dt>sign</dt>
  <dd>署名を記す。</dd>
  <dt>target</dt>
  <dd>どのフィールドを署名するか「,」で区切って並べる。</dd>
</dl>

<h3>削除通知に関連する名前付きフィールド</h3>
<dl>
  <dt>remove_stamp</dt>
  <dd>同じファイル中で削除するstamp を指定する。</dd>
  <dt>remove_id</dt>
  <dd>同じファイル中で削除するid を指定する。</dd>
</dl>

<p>通信層を共有し、別の中間層を持った実装を作ることができる。
そのような実装は「新月0.8と通信層が互換」と呼ばれる。</p>

<h2 id="application">アプリケーション層</h2>
<h3>プラグインとアプリケーション</h3>
<p>プラグインはアプリケーションを含む概念だが、まだ定義できない。
通信、署名、削除通知以外の部分がプラグインということになるだろうか。</p>

<p>プラグインのうち、
ファイルの書式を定義するものをアプリケーションと呼ぶ。
新月プロトコル0.8の定義するアプリケーションはthreadの1種類である。
かつては他に8種類のアプリケーションが存在した。
なおアプリケーションとは実装のことではない。</p>

<p>実装ではthread以外にもアプリケーションを定義することができる。
そのような実装は「新月0.8と中間層以下が互換」と呼ばれる。</p>

<h3>threadアプリケーション</h3>
<p>いわゆる掲示板のアプリケーションである。</p>

<h4>ファイル名</h4>
<p>ファイル名は「thread_エンコードされた掲示板タイトル」という形式である。
エンコードされた掲示板タイトルとは
掲示板タイトルをUTF-8で表現し、16進数表現(0-9A-F)に変換した文字列である。</p>

<h4>名前付きフィールド</h4>
<dl>
  <dt>name</dt>
  <dd>投稿者の名前</dd>

  <dt>body</dt>
  <dd>書き込みの本文。
      タグは改行を表わす「&lt;br&gt;」のみが使える。
      「&lt;BR&gt;」や「&lt;br /&gt;」は不可。</dd>

  <dt>attach</dt>
  <dd>添付付ファイルをbase64エンコードしたもの</dd>

  <dt>suffix</dt>
  <dd>添付ファイルの拡張子</dd>

  <dt>mail</dt>
  <dd>投稿者のメールアドレス</dd>

  <dt>name</dt>
  <dd>投稿者の名前</dd>
</dl>

<h2 id="group">アプリケーショングループ</h2>
<p>複数のアプリケーションが相互に連携するための規格である。</p>

<h3>Wiki式名前空間アプリケーショングループ</h3>
<p>現在はthreadのみが定義されているが、
次のような規格に従うアプリケーションを作れば
threadと連携ができる。</p>

<h4>ファイル名</h4>
<p>ファイル名は「アプリケーション名_エンコードされた掲示板タイトル」
という形式である。
エンコードされた掲示板タイトルとは
掲示板タイトルをUTF-8で表現し、16進数表現(0-9A-F)に変換した文字列である。</p>

<h4>ブラケットリンク</h4>
<p>アプリケーションは、ファイルの内容をなんらかのデータ形式に変換し、
結果を出力する場合において、
本文に次に述べるようなブラケットリンクがあるときは、
文字列が指定するリンクを作成しなければならない。</p>

<p>アプリケーションtypeが存在するとする。
標準的なブラケットリンクの形式は[[/type/文字列]] である。
文字列の形式はアプリケーション(type) が定義する。
/typeは省略することができる。
/typeを省略したブラケットリンクの形式である[[文字列]]は、
本文が記録されているファイル形式のtypeが省略されていると考える。</p>

<p>threadのブラケットリンクの作成例を次に示す。</p>

<dl>
  <dt>[[すれっど]]</dt>
  <dd>本文が記録されているファイル形式がthreadなら、
      threadの「すれっど」へリンクする。</dd>

  <dt>[[すれっど/7889e7db]]</dt>
  <dd>本文が記録されているファイル形式がthreadなら、
      thread「すれっど」の識別子「7889e7db」を持つレコードへリンクする。</dd>

  <dt>[[/thread/すれっど/7889e7db]]</dt>
  <dd>thread「すれっど」の識別子「7889e7db」を持つレコードへリンクする。</dd>
</dl>

<p>コメントください:
<a href="https://bbs.shingetsu.info/thread.cgi/%E6%96%B0%E6%9C%88%E3%81%AE%E9%96%8B%E7%99%BA">[[新月の開発]]</a></p>

>>>include "foot.ja.h"
